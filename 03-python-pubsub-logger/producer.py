# producer == new_task giver == send == emit

import sys
import pika


def produce_message(message="Hello World!..."):
    # CONNECTION = the world where this mq story happens
    # ----------------------------------------------
    # actual TCP connection to the RabbitMQ broker (the docker rabbitmq instance)
    # long lived
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost', port=5673))

    # CHANNEL = road from your house to the post office
    # ----------------------------------------------
    # AMQP connection inside that TCP connection
    # represents a session with a broker
    # short lived
    channel = connection.channel()

    # EXCHANGE = post office mail sorting department
    # ----------------------------------------------
    # make a new exchange that will take care of your queue passing
    # idempotent, so usually declared on both producer and consumer
    channel.exchange_declare(exchange="logs", exchange_type='fanout')

    # QUEUE = mailman
    # ----------------------------------------------
    # make a one time use queue (exclusive=True)
    # not giving it a name means the queue name is autogenerated
    # idempotent, so usually declared on both producer and consumer
    channel.queue_declare(queue="", durable=True)

    # PUBLISH = post on pc of mail
    # ----------------------------------------------
    # post one task to exchange
    # routing key is ignored in fanout exchanges (because it routes to everything)
    # persistent messages = mail doesn't get thrown away if the
    # post office closes down / gets destroyed, it gets collected
    # and processed again
    message = " ".join(message)
    channel.basic_publish(exchange="logs", routing_key="", body=message, properties=pika.BasicProperties(
        delivery_mode=2,  # makes messages persistent
    ))

    # XX = make sure your mail is definitely in the mailbox. equivalent to
    #        pay for your letter and see the staff put it in the mailbag
    # ----------------------------------------------
    print(" [producer] Sent %r" % message)

    # CLOSE = go home after posting your mail
    # ----------------------------------------------
    connection.close()


if __name__ == "__main__":
    for v, i in enumerate(range(10)):
        produce_message(message="Hello World! ." +
                        "".join(["." for _ in range(i)]))
