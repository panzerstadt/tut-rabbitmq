# consumer == worker == receive

import pika
import time


def callback(ch, method, properties, body):
    print(" [consumer] Received %r" % body)
    time.sleep(body.count(b'.'))
    print(" [consumer] Done")
    ch.basic_ack(delivery_tag=method.delivery_tag)


def listen_and_consume_messages():
    # CONNECTION = the world where this mq story happens
    # ----------------------------------------------
    # actual TCP connection to the RabbitMQ broker (the docker rabbitmq instance)
    # long lived
    connection = pika.BlockingConnection(
        pika.ConnectionParameters('localhost', port=5673))

    # CHANNEL = road from your house to the post office
    # ----------------------------------------------
    # AMQP connection inside that TCP connection
    # represents a session with a broker
    # short lived
    channel = connection.channel()

    # EXCHANGE = post office mail sorting department
    # ----------------------------------------------
    # make a new exchange that will take care of your queue passing
    # idempotent, so usually declared on both producer and consumer
    channel.exchange_declare(exchange="logs", exchange_type="fanout")

    # QUEUE = mailman
    # ----------------------------------------------
    # make a one time use queue (exclusive=True)
    # not giving it a name means the queue name is autogenerated
    # idempotent, so usually declared on both producer and consumer
    result = channel.queue_declare(queue="", exclusive=True)
    queue_name = result.method.queue

    # BIND = assign mailman to this post office
    # ----------------------------------------------
    # bind this one time use queue with our exchange
    channel.queue_bind(exchange="logs", queue=queue_name)

    # XX = tell the post office it's ready to work
    # ----------------------------------------------
    print(' [consumer] Waiting for messages. To exit press CTRL+C')

    # CONSUME = do the work
    # ----------------------------------------------
    # auto_ack=True means mailman tells post office that it's done WHEN HE RECEIVES IT
    # proper ack (manual, inside callback) means mailman only tells post office it's done WHEN HE FINISHES THE JOB
    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(queue=queue_name, on_message_callback=callback)

    # LISTEN = mailman will now constantly watch his assigned queue
    # ----------------------------------------------
    channel.start_consuming()


if __name__ == "__main__":
    listen_and_consume_messages()
